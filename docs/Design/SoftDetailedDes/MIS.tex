\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 12th & Rev-1 & Module M1-M11\\
Nov 12th & Rev-1 & Module M12-M22\\
Nov 13th & Rev-1 & Fix consistency\\
Nov 13th & Rev-1 & Fix correlation\\
Nov 13th & Rev-1 & Fix consistency\\
Jan 14th & Rev0 & Remove module 20,21,22\\ 
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See MG Documentation at 
\href{https://github.com/The-Crazy-Four-Games/Crazy-Eights-Game/blob/main/docs/Design/SoftArchitecture/MG.pdf}{MG}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/The-Crazy-Four-Games/Crazy-Eights-Game}. 

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[H]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.3\textwidth} p{0.3\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2} & \textbf{Level 3 (Leaf Modules)}\\
\midrule

\multirow{3}{0.3\textwidth}{Hardware-Hiding Module} & ~ & (None) \\
\midrule

\multirow{4}{0.3\textwidth}{Behaviour-Hiding Module} & (Core Domain Logic) & \hyperref[sec:game-engine-module]{M15} \\
& & \hyperref[sec:rules-module]{M16} \\
& & \hyperref[sec:scoring-module]{M17} \\
& & \hyperref[sec:base-conversion-module]{M18} \\
& & \hyperref[sec:game-actions-module]{M19} \\

\midrule

\multirow{14}{0.3\textwidth}{Software Decision Module} & \multirow{6}{0.3\textwidth}{Backend (Server)} & \hyperref[sec:api-module]{M1} \\
& & \hyperref[sec:realtime-gateway-module]{M2} \\
& & \hyperref[sec:matchmaking-module]{M3} \\
& & \hyperref[sec:authentication-module]{M4} \\
& & \hyperref[sec:repository-module]{M5} \\
& & \hyperref[sec:audit-module]{M6} \\
\cmidrule{2-3}
& \multirow{8}{0.3\textwidth}{Frontend (Client)} & \hyperref[sec:realtime-client-module]{M7} \\
& & \hyperref[sec:app-shell-module]{M8} \\
& & \hyperref[sec:auth-client-module]{M9} \\
& & \hyperref[sec:lobby-view-module]{M10} \\
& & \hyperref[sec:game-board-view-module]{M11} \\
& & \hyperref[sec:move-controller-module]{M12} \\
& & \hyperref[sec:scoreboard-view-module]{M13} \\
& & \hyperref[sec:profile-view-module]{M14} \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
\section{MIS of API Module (M1)}\label{sec:api-module}

\subsection{Module}
API

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:authentication-module]{M4 Authentication Module}
    \item \hyperref[sec:repository-module]{M5 Repository Module}
    \item \hyperref[sec:audit-module]{M6 Audit Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{APIVersion}: string := ``v1''
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
postRegister & req: RegisterRequest & HttpResponse & BadRequest, UsernameTaken, WeakPassword \\
postLogin & req: LoginRequest & HttpResponse & BadRequest, InvalidCredentials, AccountNotFound \\
postGuestSession & req: GuestSessionRequest & HttpResponse & BadRequest \\
postLogout & req: LogoutRequest & HttpResponse & BadRequest, InvalidToken \\
getProfile & req: AuthenticatedRequest & HttpResponse & Unauthorized, RecordNotFound \\
putProfile & req: UpdateProfileRequest & HttpResponse & BadRequest, Unauthorized, RecordNotFound \\
postNewGame & req: NewGameRequest & HttpResponse & BadRequest, Unauthorized \\
getHealth & req: HttpRequest & HttpResponse & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None. (Stateless HTTP routes; no persistent state is maintained by this module.)

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{HTTPServer}: The web server/runtime that receives HTTP requests and dispatches routes.
    \item \textbf{Auth}: Authentication service provided by M4.
    \item \textbf{Repository}: Persistence interface provided by M5.
    \item \textbf{Audit}: Audit logging service provided by M6.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Requests and responses follow the REST endpoint structure and payload schemas defined by the system.
    \item Authentication-protected endpoints include a session token (e.g., \texttt{Authorization} header).
    \item M4, M5, and M6 are correctly configured and available in the server runtime.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{postRegister}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req} payload (username/password). Call \textbf{Auth.createAccount}. Log an authentication audit event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} containing success status and auth token (on success).
    \item exception: \texttt{BadRequest} if payload invalid. Propagate \texttt{UsernameTaken}/\texttt{WeakPassword} from authentication logic.
\end{itemize}

\noindent\textbf{postLogin}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req}. Call \textbf{Auth.login}. Log auth event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} containing auth token (on success).
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{InvalidCredentials}/\texttt{AccountNotFound} if login fails.
\end{itemize}

\noindent\textbf{postGuestSession}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req}. Call \textbf{Auth.createGuestSession}. Log auth event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} containing guest token.
    \item exception: \texttt{BadRequest} if payload invalid.
\end{itemize}

\noindent\textbf{postLogout}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req}. Call \textbf{Auth.logout}. Log auth event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} confirming logout.
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{InvalidToken} if token invalid.
\end{itemize}

\noindent\textbf{getProfile}(\textit{req})
\begin{itemize}
    \item transition: Verify token from \textit{req} by calling \textbf{Auth.verifyToken}. On success, read user profile from \textbf{Repository} (e.g., \texttt{getPlayerProfile}/equivalent). Log a profile access event via \textbf{Audit.logSystemEvent}.
    \item output: Return \texttt{HttpResponse} containing the user profile data.
    \item exception: \texttt{Unauthorized} if token invalid/expired. \texttt{RecordNotFound} if profile/user does not exist.
\end{itemize}

\noindent\textbf{putProfile}(\textit{req})
\begin{itemize}
    \item transition: Verify token via \textbf{Auth.verifyToken}. Validate profile update payload. Update profile via \textbf{Repository} (e.g., \texttt{updatePlayerProfile}/equivalent). Log update event via \textbf{Audit.logSystemEvent}.
    \item output: Return \texttt{HttpResponse} containing updated profile.
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{Unauthorized} if token invalid/expired. \texttt{RecordNotFound} if user/profile not found.
\end{itemize}

\noindent\textbf{postNewGame}(\textit{req})
\begin{itemize}
    \item transition: Verify token via \textbf{Auth.verifyToken}. Validate request body (game setup parameters). Persist/initialize game bootstrap data via \textbf{Repository} as required by the SRS. Log gameplay/system event via \textbf{Audit.logGameplayEvent} or \textbf{Audit.logSystemEvent}. (Real-time gameplay proceeds through M2.)
    \item output: Return \texttt{HttpResponse} confirming game creation/bootstrapping and any returned identifiers.
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{Unauthorized} if token invalid/expired.
\end{itemize}

\noindent\textbf{getHealth}(\textit{req})
\begin{itemize}
    \item transition: Return basic service status (optionally include shallow checks of dependencies).
    \item output: Return \texttt{HttpResponse} with status \texttt{200 OK} when the API server is up.
    \item exception: None.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} REST endpoint structure, request/response payload schemas, and HTTP conventions for stateless backend capabilities.
    \item \textbf{Service:} exposes stateless HTTP routes for authentication, profile management, and bootstrapping new games as defined in the SRS; real-time gameplay is handled separately by M2.
    \item This module should remain stateless; persistence and security concerns are delegated to M5 and M4, while operational logging is delegated to M6.
\end{itemize}


\newpage
\section{MIS of Real-time Gateway Module (M2)}\label{sec:realtime-gateway-module}

\subsection{Module}
Real-time Gateway

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:authentication-module]{M4 Authentication Module}
    \item \hyperref[sec:repository-module]{M5 Repository Module}
    \item \hyperref[sec:game-actions-module]{M15 Game Action Module}
\end{itemize}

\subsection{Syntax}
\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{4.5cm} p{4cm} p{3.5cm} >{\raggedright\arraybackslash}p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
handleConnection & socket: ClientSocket & void & SessionError \\
handleJoinGame & socket: ClientSocket, data: JoinGameData & void & SessionError, NotFound \\
handleSubmitMove & socket: ClientSocket, data: MoveData & void & InvalidMove, NotYourTurn, SessionError \\
registerGameSession & gameID: GameID, session: GameSession & void & LobbyError \\
emitGameState & socket: ClientSocket, state: GameState & void & \\
broadcastGameState & roomID: GameID, state: GameState & void & \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{activeGames}: Map$<GameID, GameSession>$ --- A map holding the live \texttt{GameSession} objects for all currently active games.
\end{itemize}
\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{RealtimeAdapter}: The environment (e.g., a WebSocket server) that manages client connections.
    \item \textbf{ClientSocket}: An opaque handle representing a single client connection.
\end{itemize}
\subsubsection{Assumptions}
\begin{itemize}
    \item The \textbf{RealtimeAdapter} is running and forwards events to these handlers.
    \item \texttt{AuthToken} (inside \texttt{JoinGameData}) is verifiable by M4.
    \item M15 provides the legality check for the "move" operation and the state evolution.
\end{itemize}
\subsubsection{Access Routine Semantics}
\noindent\textbf{handleConnection}(\textit{socket})
\begin{itemize}
    \item transition: Registers the new \textit{socket} with the \textbf{RealtimeAdapter}. Attaches handlers for \texttt{handleJoinGame}, \texttt{handleSubmitMove}, etc.
    \item output: \texttt{void}.
    \item exception: \texttt{SessionError} if the connection handshake fails.
\end{itemize}
\noindent\textbf{handleJoinGame}(\textit{socket, data})
\begin{itemize}
    \item transition:
        1. Calls \texttt{M4.verifyToken}(\textit{data.authToken}) to get a \texttt{UserID}.
        2. Retrieves the \texttt{GameSession} from \textbf{activeGames} using \texttt{data.gameID}.
        3. Associates the \textit{socket} with the \texttt{GameSession} and \texttt{UserID}.
    \item output: Calls \texttt{emitGameState}(\textit{socket, currentState}) to send the current state to the joining player.
    \item exception: \texttt{SessionError} if \texttt{authToken} is invalid. \texttt{NotFound} if the \texttt{GameSession} does not exist in \textbf{activeGames}.
\end{itemize}
\noindent\textbf{handleSubmitMove}(\textit{socket, data})
\begin{itemize}
    \item transition: Identifies \texttt{UserID} and \texttt{GameSession} from the \textit{socket}. Calls \texttt{M19.validateAction}(\textit{data, gameState}) to check legality. If valid, calls \texttt{M19.executeAction}(\textit{data, gameState}) to get the \texttt{newGameState}. Updates the \texttt{GameSession} in \textbf{activeGames} with \texttt{newGameState}.
    \item output: Calls \texttt{broadcastGameState}(\textit{gameID, newGameState}) to send the new state to all players in that session.
    \item exception: InvalidMove. NotYourTurn. SessionError.
\end{itemize}
\noindent\textbf{registerGameSession}(\textit{gameID, session})
\begin{itemize}
    \item transition: Called by M3. Adds the new \textit{session} to the \textbf{activeGames} map.
    \item output: \texttt{void}.
    \item exception: \texttt{LobbyError} if the \textit{gameID} is already active.
\end{itemize}
\subsubsection{Local Functions}
None.
\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the management of stateful connections and the mapping of \texttt{ClientSocket} handles to active \texttt{GameSession}s.
    \item This module acts as the server-authoritative state synchronizer, delegating all game logic to M19.
\end{itemize}
\newpage
\section{MIS of Matchmaking Module (M3)}\label{sec:matchmaking-module}

\subsection{Module}
Matchmaking

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:authentication-module]{M4 Authentication Module}
    \item \hyperref[sec:game-engine-module]{M15 Game Engine Module}
    \item \hyperref[sec:realtime-gateway-module]{M2 Real-time Gateway Module}
\end{itemize}

\subsection{Syntax}
\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{4.5cm} p{3cm} >{\raggedright\arraybackslash}p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
createLobby & token: AuthToken, options: GameOptions & lobby: Lobby & LobbyError \\
joinLobby & token: AuthToken, lobbyID: LobbyID & void & LobbyFull, LobbyNotFound, AuthError \\
startMatch & token: AuthToken, lobbyID: LobbyID & gameID: GameID & LobbyNotFound, NotLobbyHost, AuthError, GameCreationError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{lobbies}: Map<LobbyID, Lobby> --- Holds all active, waiting-for-players \texttt{Lobby} objects [cite: 639-640].
\end{itemize}
\subsubsection{Environment Variables}
None.
\subsubsection{Assumptions}
\begin{itemize}
    \item Any \texttt{AuthToken} is verifiable by M4.
    \item Modules M15 and M2 are available when \texttt{startMatch} is invoked.
\end{itemize}
\subsubsection{Access Routine Semantics}
\noindent\textbf{createLobby}(\textit{token, options})
\begin{itemize}
    \item transition: Calls \texttt{M4.verifyToken}(\textit{token}) to get \texttt{UserID}. Generates a unique \texttt{LobbyID}. Creates a new \texttt{Lobby} object (setting \texttt{hostID = UserID}). Adds this new object to the \textbf{lobbies} map[cite: 636].
    \item output: Returns the newly created \texttt{Lobby}.
    \item exception: \texttt{AuthError}. \texttt{LobbyError}.
\end{itemize}
\noindent\textbf{joinLobby}(\textit{token, lobbyID})
\begin{itemize}
    \item transition: Calls \texttt{M4.verifyToken}(\textit{token}) to get \texttt{UserID}. Looks up the \texttt{Lobby} in \textbf{lobbies}. Verifies \texttt{Lobby.status == 'waiting'} and \texttt{Lobby.players.length < MAX\_PLAYERS}. If valid, appends \texttt{UserID} to the \texttt{Lobby.players} array[cite: 636].
    \item output: \texttt{void}.
    \item exception: \texttt{LobbyFull}. \texttt{LobbyNotFound}. \texttt{AuthError}.
\end{itemize}
\noindent\textbf{startMatch}(\textit{token, lobbyID})
\begin{itemize}
    \item transition:
        1. Calls \texttt{M4.verifyToken}(\textit{token}) to get \texttt{UserID}.
        2. Looks up the \texttt{Lobby} in \textbf{lobbies} and verifies \texttt{UserID} is the host.
        3. Calls \texttt{M15.createGame}(\textit{lobby.players, options}) to get a new \texttt{GameState}[cite: 669].
        4. Creates a new \texttt{GameSession} object.
        5. Calls \texttt{M2.registerGameSession}(\textit{lobbyID, newGameSession}) to hand off the session to the real-time server [cite: 630-631].
        6. Removes the \texttt{Lobby} from the \textbf{lobbies} map[cite: 636].
    \item output: Returns the \texttt{GameID} (which may be the \texttt{LobbyID}).
    \item exception: \texttt{LobbyNotFound}. \texttt{NotLobbyHost}. \texttt{AuthError}. \texttt{GameCreationError}.
\end{itemize}
\subsubsection{Local Functions}
None.
\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the \texttt{Lobby} data structure and the management of the \textbf{lobbies} map.
    \item This module bridges the stateless API (M1) and the stateful game session (M2) by handling the pre-game lobby state [cite: 636-637].
\end{itemize}
\newpage
\section{MIS of Authentication Module (M4)}\label{sec:authentication-module}

\subsection{Module}
Authentication

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
createAccount & username: string, password: string & AuthResult & UsernameTaken, WeakPassword, CredentialStoreError \\
login & username: string, password: string & AuthResult & InvalidCredentials, AccountNotFound, CredentialStoreError \\
createGuestSession & deviceId: string & AuthResult & CredentialStoreError \\
logout & token: SessionToken & void & InvalidToken \\
issueToken & userId: UserID, role: UserRole & SessionToken & TokenSigningError \\
verifyToken & token: SessionToken & TokenClaims & InvalidToken, ExpiredToken, TokenSigningError \\
refreshToken & token: SessionToken & SessionToken & InvalidToken, ExpiredToken, TokenSigningError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{hashConfig}: Configuration for password hashing (e.g., algorithm selection, cost parameters).
    \item \textbf{tokenSigner}: A component holding token-signing capability (e.g., HMAC secret or private key handle).
    \item \textbf{credentialStore}: Internal credential storage mechanism used by this module (implementation-defined).
    \item \textbf{activeSessions}: A mapping from \texttt{SessionToken} to session metadata (e.g., \texttt{userId}, \texttt{expiry}, \texttt{role}). (If sessions are stateless JWTs, this may be minimal or omitted.)
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{TokenSigningKey}: Secret key material used to sign/verify tokens (stored securely outside the codebase).
    \item \textbf{SystemClock}: Source of current time used for expiry validation.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Password hashing configuration is correctly set and kept consistent across deployments.
    \item \textbf{TokenSigningKey} is available and protected (not exposed to clients).
    \item The internal \textbf{credentialStore} is available and correctly initialized.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{createAccount}(\textit{username, password})
\begin{itemize}
    \item transition: Validate \textit{username} format and \textit{password} strength. Hash \textit{password} using \textbf{hashConfig}. Store account and credential info in \textbf{credentialStore}. Issue a session token for the new account via \textbf{issueToken}.
    \item output: Return \texttt{AuthResult} containing (at minimum) a \texttt{SessionToken} and user identity information.
    \item exception: \texttt{UsernameTaken} if \textit{username} already exists in \textbf{credentialStore}. \texttt{WeakPassword} if \textit{password} fails policy. \texttt{CredentialStoreError} if storage fails.
\end{itemize}

\noindent\textbf{login}(\textit{username, password})
\begin{itemize}
    \item transition: Retrieve credential record for \textit{username} from \textbf{credentialStore}. Verify \textit{password} against stored hash. On success, issue a new token via \textbf{issueToken}.
    \item output: Return \texttt{AuthResult} containing a valid \texttt{SessionToken}.
    \item exception: \texttt{AccountNotFound} if \textit{username} does not exist. \texttt{InvalidCredentials} if verification fails. \texttt{CredentialStoreError} if retrieval fails.
\end{itemize}

\noindent\textbf{createGuestSession}(\textit{deviceId})
\begin{itemize}
    \item transition: Create or reuse a guest identity bound to \textit{deviceId} (policy-defined). Store minimal guest metadata in \textbf{credentialStore} if required. Issue a guest token via \textbf{issueToken}.
    \item output: Return \texttt{AuthResult} containing a guest \texttt{SessionToken}.
    \item exception: \texttt{CredentialStoreError} if storage fails.
\end{itemize}

\noindent\textbf{logout}(\textit{token})
\begin{itemize}
    \item transition: Invalidate \textit{token}. If tokens are stateless, record the token (or its identifier) in a denylist until expiry; otherwise remove from \textbf{activeSessions}.
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidToken} if \textit{token} is malformed or cannot be invalidated under the configured policy.
\end{itemize}

\noindent\textbf{issueToken}(\textit{userId, role})
\begin{itemize}
    \item transition: Construct token claims (e.g., \textit{userId}, \textit{role}, issued-at, expiry). Sign token using \textbf{tokenSigner} backed by \textbf{TokenSigningKey}.
    \item output: Return a signed \texttt{SessionToken}.
    \item exception: \texttt{TokenSigningError} if signing fails or key material is unavailable.
\end{itemize}

\noindent\textbf{verifyToken}(\textit{token})
\begin{itemize}
    \item transition: Verify signature using \textbf{TokenSigningKey}. Validate expiry against \textbf{SystemClock}. Optionally check denylist / \textbf{activeSessions}.
    \item output: Return \texttt{TokenClaims} extracted from the token.
    \item exception: \texttt{InvalidToken} if signature/format validation fails. \texttt{ExpiredToken} if expiry has passed. \texttt{TokenSigningError} if verification fails due to key issues.
\end{itemize}

\noindent\textbf{refreshToken}(\textit{token})
\begin{itemize}
    \item transition: Verify \textit{token} via \textbf{verifyToken}. If eligible for refresh, issue a new token with extended expiry via \textbf{issueToken}. Optionally revoke the old token (denylist) depending on policy.
    \item output: Return a new \texttt{SessionToken}.
    \item exception: \texttt{InvalidToken} if verification fails. \texttt{ExpiredToken} if the token is no longer refreshable. \texttt{TokenSigningError} if issuing the new token fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} password hashing configuration, credential storage details, and token-signing keys.
    \item \textbf{Service:} creates accounts, validates logins, manages guest sessions, and issues/verifies tokens used by the rest of the backend.
    \item Other backend modules should not handle raw passwords or token signing directly; they should rely on this module's access routines.
    \item If hashing algorithms or token mechanisms change, modifications are localized to this module; callers remain unchanged.
\end{itemize}

\newpage
\section{MIS of Repository Module (M5)}\label{sec:repository-module}

\subsection{Module}
Repository

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
findPlayerByUsername & username: string & Player & RecordNotFound, DatabaseConnectionError \\
findPlayerById & playerId: PlayerID & Player & RecordNotFound, DatabaseConnectionError \\
createPlayer & data: PlayerData & Player & UniqueConstraintViolation, DatabaseConnectionError \\
updatePlayerProfile & playerId: PlayerID, data: PlayerProfileData & Player & RecordNotFound, DatabaseConnectionError \\
storeCredential & playerId: PlayerID, cred: CredentialData & void & RecordNotFound, UniqueConstraintViolation, DatabaseConnectionError \\
getCredentialByUsername & username: string & CredentialRecord & RecordNotFound, DatabaseConnectionError \\
saveMatchResult & result: MatchResult & void & DatabaseConnectionError \\
getMatchHistory & playerId: PlayerID, limit: nat, offset: nat & seq of MatchResult & DatabaseConnectionError \\
getPlayerStats & playerId: PlayerID & PlayerStats & RecordNotFound, DatabaseConnectionError \\
deletePlayer & playerId: PlayerID & void & RecordNotFound, DatabaseConnectionError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{dbConnectionPool}: A connection pool managing active connections to the PostgreSQL database.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{PostgreSQLServer}: The external PostgreSQL database instance that executes all SQL queries.
    \item \textbf{DBConnectionString}: A secure configuration value used to initialize database connectivity.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item \textbf{PostgreSQLServer} is running and reachable from the server-side runtime.
    \item \textbf{DBConnectionString} is provided securely and grants appropriate permissions.
    \item The database schema for players, credentials, match history, and statistics is initialized and consistent with this module's queries.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{findPlayerByUsername}(\textit{username})
\begin{itemize}
    \item transition: Acquire a connection from \textbf{dbConnectionPool}. Execute a SQL \texttt{SELECT} over the player table filtered by \textit{username}.
    \item output: Return the \texttt{Player} record.
    \item exception: \texttt{RecordNotFound} if no player matches \textit{username}. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{findPlayerById}(\textit{playerId})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} over the player table filtered by \textit{playerId}.
    \item output: Return the \texttt{Player} record.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{createPlayer}(\textit{data})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{INSERT} to create a new player using \textit{data}.
    \item output: Return the created \texttt{Player} (including generated \texttt{PlayerID}).
    \item exception: \texttt{UniqueConstraintViolation} if a unique field (e.g., username) already exists. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{updatePlayerProfile}(\textit{playerId, data})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{UPDATE} to modify the profile fields for \textit{playerId} using \textit{data}.
    \item output: Return the updated \texttt{Player}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{storeCredential}(\textit{playerId, cred})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{INSERT} (or \texttt{UPSERT}, if supported by the schema) to store credential material for \textit{playerId}.
    \item output: \texttt{void}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{UniqueConstraintViolation} if the credential record violates a uniqueness rule. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{getCredentialByUsername}(\textit{username})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} joining username $\rightarrow$ player $\rightarrow$ credential record (schema-dependent).
    \item output: Return the \texttt{CredentialRecord}.
    \item exception: \texttt{RecordNotFound} if no credential is found for \textit{username}. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{saveMatchResult}(\textit{result})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{INSERT} into match history / results tables using \textit{result}.
    \item output: \texttt{void}.
    \item exception: \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{getMatchHistory}(\textit{playerId, limit, offset})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} over match history filtered by \textit{playerId}, ordered by time, returning a window defined by \textit{limit} and \textit{offset}.
    \item output: Return a sequence of \texttt{MatchResult}.
    \item exception: \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{getPlayerStats}(\textit{playerId})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} (and/or aggregate queries) to retrieve computed statistics for \textit{playerId}.
    \item output: Return \texttt{PlayerStats}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist (or has no stats record per schema). \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{deletePlayer}(\textit{playerId})
\begin{itemize}
    \item transition: Acquire a connection. Execute SQL \texttt{DELETE} operations (possibly cascading per schema) to remove the player and related records.
    \item output: \texttt{void}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the database implementation (PostgreSQL), schema design, optimized SQL queries, and database access strategies (e.g., pooling, transactions).
    \item \textbf{Service:} provides a clean persistence interface for storing and retrieving players, credentials, match history, and statistics, shielding callers from database specifics.
    \item This module abstracts all CRUD operations and schema details; callers never issue SQL directly.
    \item If the persistence technology changes (e.g., PostgreSQL to another DB), only this module needs to be rewritten; callers remain unchanged.
\end{itemize}

\newpage
\section{MIS of Audit Module (M6)}\label{sec:audit-module}

\subsection{Module}
Audit

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DefaultRetentionDays}: nat := 30
    \item \textbf{MaxEventPayloadSize}: nat := 8192 \quad (bytes)
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
logAuthEvent & event: AuthAuditEvent & void & LogStoreError \\
logGameplayEvent & event: GameplayAuditEvent & void & LogStoreError \\
logSystemEvent & event: SystemAuditEvent & void & LogStoreError \\
queryAuditEvents & filter: AuditQueryFilter & seq of AuditEvent & LogStoreError \\
purgeExpiredEvents & retentionDays: nat & nat & LogStoreError \\
redactEventPayload & eventId: AuditEventID, fields: seq of string & void & RecordNotFound, LogStoreError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{retentionPolicyDays}: nat := \textbf{DefaultRetentionDays}
    \item \textbf{logStore}: Internal storage target/driver for audit events (implementation-defined; may be DB table, file sink, external log service).
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{SystemClock}: Source of current time for timestamps and retention enforcement.
    \item \textbf{AuditStorageConfig}: Configuration describing storage target(s), retention, and access credentials for the logging backend.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The event schema (fields for authentication/gameplay/system events) matches the storage format used by \textbf{logStore}.
    \item The storage target(s) configured by \textbf{AuditStorageConfig} are reachable during normal operation.
    \item Retention policies are chosen to satisfy operational debugging, security, and compliance requirements.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{logAuthEvent}(\textit{event})
\begin{itemize}
    \item transition: Validate \textit{event} payload size $\le$ \textbf{MaxEventPayloadSize}. Attach timestamp from \textbf{SystemClock}. Serialize and append/store in \textbf{logStore} using the authentication-event schema.
    \item output: \texttt{void}.
    \item exception: \texttt{LogStoreError} if storage/append fails.
\end{itemize}

\noindent\textbf{logGameplayEvent}(\textit{event})
\begin{itemize}
    \item transition: Validate payload size and required fields. Attach timestamp. Serialize and append/store in \textbf{logStore} using the gameplay-event schema.
    \item output: \texttt{void}.
    \item exception: \texttt{LogStoreError} if storage/append fails.
\end{itemize}

\noindent\textbf{logSystemEvent}(\textit{event})
\begin{itemize}
    \item transition: Validate payload size and required fields. Attach timestamp. Serialize and append/store in \textbf{logStore} using the system-event schema.
    \item output: \texttt{void}.
    \item exception: \texttt{LogStoreError} if storage/append fails.
\end{itemize}

\noindent\textbf{queryAuditEvents}(\textit{filter})
\begin{itemize}
    \item transition: Translate \textit{filter} constraints (time window, event type, user/session identifiers, severity, correlation id, etc.) into \textbf{logStore} query operations. Execute query against \textbf{logStore}. Apply any post-filters (e.g., pagination) as required.
    \item output: Return a sequence of \texttt{AuditEvent} matching \textit{filter}.
    \item exception: \texttt{LogStoreError} if querying fails.
\end{itemize}

\noindent\textbf{purgeExpiredEvents}(\textit{retentionDays})
\begin{itemize}
    \item transition: Compute cutoff time = \textbf{SystemClock} $-$ \textit{retentionDays}. Delete, archive, or compact entries older than cutoff according to \textbf{AuditStorageConfig} policy.
    \item output: Return the number of events purged (nat).
    \item exception: \texttt{LogStoreError} if purge/archive fails.
\end{itemize}

\noindent\textbf{redactEventPayload}(\textit{eventId, fields})
\begin{itemize}
    \item transition: Locate \textit{eventId} in \textbf{logStore}. Replace, mask, or remove specified \textit{fields} in the persisted payload (schema-dependent). Persist the redacted version and mark the record as redacted.
    \item output: \texttt{void}.
    \item exception: \texttt{RecordNotFound} if \textit{eventId} does not exist. \texttt{LogStoreError} if update/writeback fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the exact event schema, retention policy, and storage targets for operational logs.
    \item \textbf{Service:} captures authentication, gameplay, and system events to support debugging, compliance, security, and user inquiries.
    \item This module is a library utility; it should not impose dependencies on other modules.
    \item If storage targets or retention strategies change, updates are localized to this module; event producers remain unchanged as long as the API is stable.
\end{itemize}

\newpage
\section{MIS of Real-time Client Module (M7)}\label{sec:realtime-client-module}

\subsection{Module}
Real-time Client

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:realtime-gateway-module]{M2  Real-time Gateway Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{6cm} p{2.5cm} p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
connect & - & void & ConnectionFailed \\
disconnect & - & void & \\
on & eventName: 'gameStateUpdate', callback: (state) => void & void & \\
emit & eventName: 'submitMove', move: Move & void & ConnectionFailed \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{socket}: Socket --- The \texttt{Socket.io-client} instance.
    \item \textbf{isConnected}: bool --- Flag indicating the connection status.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{BrowserRuntime (M21)}: The client's web browser environment providing WebSocket APIs.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The M2 server is running and its URL is accessible to the client.
    \item The browser environment (M21) supports WebSockets.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{connect}(\,)
\begin{itemize}
    \item transition: Initializes and establishes the WebSocket connection to M2. Sets \textbf{socket} to the new instance and \textbf{isConnected} to \texttt{true} on success.
    \item output: \texttt{void}.
    \item exception: \texttt{ConnectionFailed} if the connection times out or is rejected.
\end{itemize}

\noindent\textbf{disconnect}(\,)
\begin{itemize}
    \item transition: Closes the active WebSocket connection. Sets \textbf{isConnected} to \texttt{false} and \textbf{socket} to \texttt{null}.
    \item output: \texttt{void}.
\end{itemize}

\noindent\textbf{on}(\textit{eventName, callback})
\begin{itemize}
    \item transition: Registers an event listener on the \textbf{socket} instance. When M2 emits an event matching \textit{eventName} (e.g., 'gameStateUpdate'), the \textit{callback} is invoked with the data payload.
    \item output: \texttt{void}.
\end{itemize}

\noindent\textbf{emit}(\textit{eventName, move})
\begin{itemize}
    \item transition: Serializes and sends the \textit{move} data to the M2 server over the \textbf{socket} connection, under the \textit{eventName} (e.g., 'submitMove').
    \item output: \texttt{void}.
    \item exception: \texttt{ConnectionFailed} if \textbf{isConnected} is \texttt{false}.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the WebSocket connection state and reconnection logic.
    \item It is the client-side counterpart to M2.
    \item UI modules (e.g., M11, M12) use this module to receive state updates and send user actions.
\end{itemize}
\newpage
\section{MIS of Application Shell Module (M8)}\label{sec:app-shell-module}

\subsection{Module}
Application Shell

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:browser-runtime-module]{M21 Browser Runtime Module}
    \item \hyperref[sec:auth-client-module]{M9 Authentication Client Module}
    \item \hyperref[sec:lobby-view-module]{M10 Lobby View Module}
    \item \hyperref[sec:game-board-view-module]{M11 Game Board View Module}
    \item \hyperref[sec:profile-view-module]{M14 Profile View Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
Render & props: ReactProps & JSX.Element & RouteNotFound \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentUser}: User | null --- Stores the state of the currently logged-in user.
    \item \textbf{currentRoute}: string --- The active route from the browser's URL.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{BrowserRuntime (M21)}: The browser environment providing the DOM for rendering and the URL History API for routing.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The React library is loaded in the M21 environment.
    \item The browser supports the History API.
    \item Modules M9, M10, M11, and M14 are available to be rendered as children.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{Render}(\textit{props})
\begin{itemize}
    \item transition: Reads the URL path from the \textbf{BrowserRuntime (M20)} to update \textbf{currentRoute}. Reads the authentication status to update \textbf{currentUser}. Renders the global layout (header, footer). Selectively renders a child module (M9, M10, M11, or M14) based on \textbf{currentRoute} and \textbf{currentUser}.
    \item output: Returns a React Element (\texttt{JSX.Element}) for the \textbf{BrowserRuntime (M20)} to render to the DOM.
    \item exception: \texttt{RouteNotFound} if \textbf{currentRoute} does not match any entry in the application's routing table.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the application routing table and the global layout structure.
    \item This module acts as a controller view, deciding which page (M10, M11, M14) to display based on URL and authentication state.
\end{itemize}
\newpage
\section{MIS of Authentication Client Module (M9)}\label{sec:authentication-client-module}

\subsection{Module}
Authentication Client

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:api-module]{M1 API Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{TokenStorageKey}: string := ``authToken''
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
renderLoginForm & None & ViewModel & None \\
renderSignupForm & None & ViewModel & None \\
submitLogin & username: string, password: string & AuthViewState & InvalidInput, AuthFailed, NetworkError \\
submitSignup & username: string, password: string & AuthViewState & InvalidInput, AuthFailed, NetworkError \\
submitLogout & None & AuthViewState & NetworkError \\
storeToken & token: string & void & TokenStorageError \\
loadToken & None & OptionalString & TokenStorageError \\
clearToken & None & void & TokenStorageError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentToken}: OptionalString \quad (cached token currently held by the client)
    \item \textbf{authStatus}: AuthStatus \quad (e.g., \texttt{LoggedOut}, \texttt{LoggingIn}, \texttt{LoggedIn}, \texttt{Error})
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: Browser/client framework runtime that renders UI and handles events.
    \item \textbf{SecureStorage}: Client-side storage mechanism (e.g., cookie/local storage/session storage), implementation-defined.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The client calls M1 for authentication-related HTTP requests (login/signup/logout).
    \item Token storage is best-effort secure according to the chosen client storage mechanism.
    \item Network calls may fail; the UI reports errors to the user.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{renderLoginForm}()
\begin{itemize}
    \item transition: Construct a login form view model (username/password inputs, submit action, error placeholder).
    \item output: Return the \texttt{ViewModel} for the login form.
    \item exception: None.
\end{itemize}

\noindent\textbf{renderSignupForm}()
\begin{itemize}
    \item transition: Construct a signup form view model (username/password inputs, submit action, error placeholder).
    \item output: Return the \texttt{ViewModel} for the signup form.
    \item exception: None.
\end{itemize}

\noindent\textbf{submitLogin}(\textit{username, password})
\begin{itemize}
    \item transition: Validate inputs (non-empty, basic format checks). Call M1 authentication route (e.g., \texttt{postLogin}). On success, extract token from the response and call \textbf{storeToken}. Update \textbf{currentToken} and \textbf{authStatus}.
    \item output: Return \texttt{AuthViewState} indicating success/failure and any user-facing message.
    \item exception: \texttt{InvalidInput} if validation fails. \texttt{AuthFailed} if server rejects credentials. \texttt{NetworkError} if request fails.
\end{itemize}

\noindent\textbf{submitSignup}(\textit{username, password})
\begin{itemize}
    \item transition: Validate inputs. Call M1 authentication route (e.g., \texttt{postRegister}). On success, store returned token via \textbf{storeToken}. Update \textbf{currentToken} and \textbf{authStatus}.
    \item output: Return \texttt{AuthViewState} indicating success/failure and any user-facing message.
    \item exception: \texttt{InvalidInput} if validation fails. \texttt{AuthFailed} if server rejects signup. \texttt{NetworkError} if request fails.
\end{itemize}

\noindent\textbf{submitLogout}()
\begin{itemize}
    \item transition: If \textbf{currentToken} exists, call M1 logout route (e.g., \texttt{postLogout}) best-effort. Call \textbf{clearToken}. Set \textbf{currentToken} := None and \textbf{authStatus} := \texttt{LoggedOut}.
    \item output: Return \texttt{AuthViewState} indicating the user is logged out.
    \item exception: \texttt{NetworkError} if the logout request fails (token clearing still proceeds locally).
\end{itemize}

\noindent\textbf{storeToken}(\textit{token})
\begin{itemize}
    \item transition: Persist \textit{token} into \textbf{SecureStorage} under \textbf{TokenStorageKey}. Set \textbf{currentToken} := \textit{token}.
    \item output: \texttt{void}.
    \item exception: \texttt{TokenStorageError} if the storage operation fails.
\end{itemize}

\noindent\textbf{loadToken}()
\begin{itemize}
    \item transition: Read token from \textbf{SecureStorage} under \textbf{TokenStorageKey}. If present, set \textbf{currentToken} := token; otherwise set \textbf{currentToken} := None.
    \item output: Return \textbf{currentToken}.
    \item exception: \texttt{TokenStorageError} if the storage read fails.
\end{itemize}

\noindent\textbf{clearToken}()
\begin{itemize}
    \item transition: Remove \textbf{TokenStorageKey} from \textbf{SecureStorage}. Set \textbf{currentToken} := None.
    \item output: \texttt{void}.
    \item exception: \texttt{TokenStorageError} if removal fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} decisions about secure token storage and the flows for refreshing or clearing credentials in the browser.
    \item \textbf{Service:} presents login, signup, and logout experiences while coordinating with \textbf{M1} for authentication calls.
    \item \textbf{Type Note:} \texttt{OptionalString = string $\cup$ \{None\}}.
\end{itemize}

\newpage
\section{MIS of Lobby View Module (M10)}\label{sec:lobby-view-module}

\subsection{Module}
Lobby View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:api-module]{M1 API Module}
    \item \hyperref[sec:realtime-client-module]{M7 Real-time Client Module}
    \item \hyperref[sec:browser-runtime-module]{M21 Browser Runtime Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
Render & props: ReactProps & JSX.Element & \\
handleCreateGame & - & void & CreateGameError \\
handleJoinGame & lobbyID: LobbyID & void & JoinGameError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{lobbiesList}: Lobby[] --- An array of available game lobbies.
    \item \textbf{selectedLobby}: LobbyID | null --- The ID of the lobby currently selected in the UI.
    \item \textbf{isLoading}: bool --- True if a create or join operation is in progress.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{BrowserRuntime (M21)}: The browser environment providing DOM rendering.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Modules M1 and M7 are available and configured.
    \item This module is rendered by M8 (Application Shell).
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{Render}(\textit{props})
\begin{itemize}
    \item transition: Reads \textbf{lobbiesList}, \textbf{selectedLobby}, and \textbf{isLoading} from state.
    \item output: Returns a \texttt{JSX.Element} that renders the UI for listing, creating, and joining game lobbies. Renders a loading indicator if \textbf{isLoading} is true.
\end{itemize}

\noindent\textbf{handleCreateGame}(\,)
\begin{itemize}
    \item transition: Sets \textbf{isLoading} to \texttt{true}. Calls \texttt{M1.createGame} to create a new lobby. On success, receives a \texttt{newLobbyID} and calls \texttt{handleJoinGame(newLobbyID)}.
    \item output: \texttt{void}.
    \item exception: \texttt{CreateGameError} (displayed in UI) if the M1 call fails.
\end{itemize}

\noindent\textbf{handleJoinGame}(\textit{lobbyID})
\begin{itemize}
    \item transition: Sets \textbf{isLoading} to \texttt{true}. Calls \texttt{M7.emit('joinGame', \{ lobbyID: lobbyID, ... \})}. On success, the M7/M2 connection will trigger a state change that M8 will use to render M11.
    \item output: \texttt{void}.
    \item exception: \texttt{JoinGameError} (displayed in UI) if M7 fails to join.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the UI layout for displaying, creating, and joining games.
    \item It coordinates user actions, calling M1 for lobby creation and M7 for joining a real-time session.
\end{itemize}

\newpage
\section{MIS of Game Board View Module (M11)}\label{sec:game-board-view-module}

\subsection{Module}
Game Board View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:browser-runtime-module]{M21 Browser Runtime Module}
    \item \hyperref[sec:move-controller-module]{M12 Move Controller Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
Render & props: ReactProps & JSX.Element & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{clientGameState}: GameState --- The current game state object (hands, deck, discard pile).
    \item \textbf{validMoves}: Card[] --- An array of cards in the player's hand that are legal to play.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{BrowserRuntime (M21)}: The browser environment providing DOM rendering and CSS.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item This module is rendered by M8 when a game is active.
    \item The \textbf{clientGameState} and \textbf{validMoves} are provided (likely as props).
    \item Event handlers from M12 are attached to the rendered elements.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{Render}(\textit{props})
\begin{itemize}
    \item transition: Reads \textbf{clientGameState} and \textbf{validMoves} from state/props.
    \item output: Returns a \texttt{JSX.Element} that renders the main game interface, including the player's hand, the discard pile, and the deck. It visually highlights any cards in the hand that are also present in the \textbf{validMoves} list.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the DOM/CSS structure and animation logic used to render the game board.
    \item This is primarily a "dumb" rendering component; it displays state and delegates user input handling to M12.
\end{itemize}
\newpage
\section{MIS of Move Controller Module (M12)}\label{sec:move-controller-module}

\subsection{Module}
Move Controller

\subsection{Uses}
\begin{itemize}
    \item Real-time Client Module (M7)
    \item Browser Runtime Module (M21)
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{3.5cm} p{3cm} >{\raggedright\arraybackslash}p{4cm}}
    \toprule
    \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \midrule
    handlePlayCard & card: Card & void & InvalidMoveUI \\
    handleDrawCard & - & void & InvalidMoveUI \\
    \bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{selectedCard}: Card
    \item \textbf{uiFeedback}: string
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{BrowserRuntime (M21)}: Provides user input events from the UI.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Module M7 is connected.
    \item These access programs are bound to UI elements rendered by M11.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{handlePlayCard}(\textit{card})
\begin{itemize}
    \item transition: Performs client-side pre-validation. If invalid, sets \textbf{uiFeedback}. If valid, calls \texttt{M7.emit('submitMove', \{ action: 'play', payload: card \})}.
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidMoveUI} (captured in \textbf{uiFeedback} state).
\end{itemize}

\noindent\textbf{handleDrawCard}(\,)
\begin{itemize}
    \item transition: Performs client-side pre-validation. If invalid, sets \textbf{uiFeedback}. If valid, calls \texttt{M7.emit('submitMove', \{ action: 'draw' \})}.
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidMoveUI} (captured in \textbf{uiFeedback} state).
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{clientSidePreValidation(...)}: Local logic to pre-check moves.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item The secret of this module is the client-side input handling logic and pre-validation rules.
    \item It decouples the M11 view from the M7 client service.
\end{itemize}

\newpage
\section{MIS of Scoreboard View Module (M13)}\label{sec:scoreboard-view-module}

\subsection{Module}
Scoreboard View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:base-conversion-module]{M18 Base Conversion Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DefaultScoreBase}: nat := 10
    \item \textbf{AlternateScoreBase}: nat := 12
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
renderScoreboard & data: ScoreboardData & ViewModel & InvalidScoreData \\
toggleScoreBase & base: nat & void & InvalidBase \\
formatScore & score: int, base: nat & string & InvalidBase, InvalidScoreData \\
renderRoundSummary & summary: RoundSummaryData & ViewModel & InvalidScoreData \\
animateRoundTransition & from: ViewModel, to: ViewModel & void & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentBase}: nat := \textbf{DefaultScoreBase}
    \item \textbf{lastRendered}: ViewModel \quad (cached view state for transitions/animations)
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: The client-side framework/runtime responsible for rendering UI components and handling user interactions.
    \item \textbf{DisplayPreferences}: User/UI preferences (e.g., preferred score base, accessibility settings).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input scores in \texttt{ScoreboardData} are valid integers produced by the game logic.
    \item Dozenal formatting uses the digit-symbol mapping provided by \textbf{M18}.
    \item The client runtime supports re-rendering and simple transitions/animations.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{renderScoreboard}(\textit{data})
\begin{itemize}
    \item transition: Validate \textit{data} (players, ordering, score values). For each displayed score, call \textbf{formatScore} to produce both decimal and dozenal strings (or the currently selected base). Produce a \texttt{ViewModel} suitable for rendering, and update \textbf{lastRendered}.
    \item output: Return the constructed \texttt{ViewModel}.
    \item exception: \texttt{InvalidScoreData} if \textit{data} is missing required fields or contains invalid score values.
\end{itemize}

\noindent\textbf{toggleScoreBase}(\textit{base})
\begin{itemize}
    \item transition: If \textit{base} is \textbf{DefaultScoreBase} or \textbf{AlternateScoreBase}, set \textbf{currentBase} := \textit{base} and update \textbf{DisplayPreferences} if applicable; otherwise reject.
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidBase} if \textit{base} is not supported.
\end{itemize}

\noindent\textbf{formatScore}(\textit{score, base})
\begin{itemize}
    \item transition: Validate \textit{score}. If \textit{base} = 10, convert \textit{score} to decimal string using standard formatting. If \textit{base} = 12, call \textbf{M18.decimalToDozenal}(\textit{score}) to obtain the dozenal string.
    \item output: Return the formatted score string.
    \item exception: \texttt{InvalidBase} if \textit{base} is unsupported. \texttt{InvalidScoreData} if \textit{score} is not a valid integer (implementation-defined).
\end{itemize}

\noindent\textbf{renderRoundSummary}(\textit{summary})
\begin{itemize}
    \item transition: Validate \textit{summary} fields (round index, deltas, totals). Format all displayed score values using \textbf{formatScore}. Produce a summary \texttt{ViewModel} for end-of-round display.
    \item output: Return the summary \texttt{ViewModel}.
    \item exception: \texttt{InvalidScoreData} if \textit{summary} is malformed or contains invalid scores.
\end{itemize}

\noindent\textbf{animateRoundTransition}(\textit{from, to})
\begin{itemize}
    \item transition: Run client-side UI animation/transition from \textit{from} to \textit{to} (implementation-defined). Update \textbf{lastRendered} := \textit{to}.
    \item output: \texttt{void}.
    \item exception: None.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} presentation choices for multi-base score displays and animations for round summaries.
    \item \textbf{Service:} shows standings after each round, presenting both decimal and dozenal scores in a clear, accessible format.
    \item This is a client-side UI module; it should not contain core scoring logic, only formatting and presentation. Numeric base conversion details are delegated to \textbf{M18}.
\end{itemize}

\newpage
\section{MIS of Profile View Module (M14)}\label{sec:profile-view-module}

\subsection{Module}
Profile View Module

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:auth-client-module]{M9 Authentication Client Module}
    \item \hyperref[sec:scoring-module]{M17 Scoring Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4cm} p{3.5cm} p{3cm} p{3.5cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        loadProfile & PlayerID & ProfileData & DatabaseReadError \\
        updateProfile & PlayerID, ProfileData & None & DatabaseWriteError \\
        renderProfile & ProfileData & None & None \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentProfile}: cached profile data of the active player.
    \item \textbf{sessionStats}: recent gameplay summary for quick access.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Backend database connection or local storage; user interface display frame.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Each player has a unique identifier.
    \item Profile data is fetched before rendering.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{loadProfile}(\textit{PlayerID})
\begin{itemize}
    \item transition: retrieves stored profile data from database or cache.
    \item output: \texttt{ProfileData}.
\end{itemize}

\noindent\textbf{updateProfile}(\textit{PlayerID, ProfileData})
\begin{itemize}
    \item transition: commits new statistics or preferences to persistent storage.
    \item output: \texttt{None}.
\end{itemize}

\noindent\textbf{renderProfile}(\textit{ProfileData})
\begin{itemize}
    \item transition: displays the users avatar, username, and score summary.
    \item output: \texttt{None}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{formatStats()}: formats match statistics for display.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item This module must protect user data integrity and minimize latency when loading or updating profile information.
\end{itemize}

\newpage
\section{MIS of Game Engine Module (M15)}\label{sec:game-engine-module}

\subsection{Module}
Game Engine

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:rules-module]{M16 Rules Module}
    \item \hyperref[sec:scoring-module]{M17 Scoring Module}
    \item \hyperref[sec:game-actions-module]{M19 Game Actions Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4cm} p{3.5cm} p{3cm} p{4cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        initializeGame & PlayerList & GameState & InvalidSetupException \\
        processTurn & Action & GameState & InvalidActionException \\
        checkWinCondition & GameState & Boolean & None \\
        reshuffleDeck & None & None & EmptyDeckException \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentState}: current configuration of the game.
    \item \textbf{activePlayer}: player ID whose turn is in progress.
    \item \textbf{drawPile, discardPile}: sets of remaining and played cards.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Game state repository, player actions, and random seed generator.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Each player performs one valid action per turn.
    \item Randomness is seeded for reproducibility.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{initializeGame}(\textit{PlayerList})
\begin{itemize}
    \item transition: distributes cards, sets starting player, and creates the discard pile.
    \item output: \texttt{GameState}.
\end{itemize}

\noindent\textbf{processTurn}(\textit{Action})
\begin{itemize}
    \item transition: validates and executes one action, then triggers scoring update.
    \item output: \texttt{GameState}.
\end{itemize}

\noindent\textbf{checkWinCondition}(\textit{GameState})
\begin{itemize}
    \item output: evaluates if any player has no cards remaining.
\end{itemize}

\noindent\textbf{reshuffleDeck}(\,)
\begin{itemize}
    \item transition: moves discard cards back into draw pile and randomizes order.
    \item output: \texttt{None}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{advanceTurn()}: calculates next player index.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item The module must maintain consistency across all players and prevent race conditions during state transitions.
\end{itemize}

\newpage
\section{MIS of Rules Module (M16)}\label{sec:rules-module}

\subsection{Module}
Rules

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:base-conversion-module]{M18 Base Conversion Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DozenalBase}: nat := 12
    \item \textbf{DozenalTarget}: string := ``10'' \quad (base-12)
    \item \textbf{DozenalTargetDecimal}: nat := 12 \quad (= M18.dozenalToDecimal(\textbf{DozenalTarget}))
    \item \textbf{InitialHandSize}: nat := 5
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
initRound & deck: Deck, players: seq of PlayerID & RoundState & InvalidDeck, InvalidPlayers \\
isPlayable & state: RoundState, playerId: PlayerID, card: Card & boolean & InvalidRoundState, InvalidPlayer, InvalidCard \\
getPlayableCards & state: RoundState, playerId: PlayerID & seq of Card & InvalidRoundState, InvalidPlayer \\
applyPlay & state: RoundState, playerId: PlayerID, card: Card, chosenSuit: Suit? & RoundState & IllegalMove, InvalidRoundState, InvalidPlayer, InvalidCard, InvalidSuitChoice \\
mustDraw & state: RoundState, playerId: PlayerID & boolean & InvalidRoundState, InvalidPlayer \\
applyDraw & state: RoundState, playerId: PlayerID & RoundState & EmptyDeck, InvalidRoundState, InvalidPlayer \\
isRoundOver & state: RoundState & boolean & InvalidRoundState \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None. (This module is stateless; all game situation is carried in \texttt{RoundState}.)

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item This module currently supports 1v1 gameplay (two players) for round initialization and legality checks.
    \item \texttt{RoundState} contains: \texttt{hands} (mapping from \texttt{PlayerID} to a sequence of \texttt{Card}), \texttt{drawPile}, \texttt{discardPile}, \texttt{topCard}, \texttt{currentTurn}, and an optional \texttt{forcedSuit}.
    \item A \textbf{wildcard} is the rank ``10'' and is always playable regardless of suit/rank/sum constraints.
    \item A \textbf{face card} does not participate in the dozenal-sum rule; it can only be played via match-suit or match-rank (unless it is a wildcard).
    \item The dozenal-sum rule target is base-12 ``10'' (i.e., decimal 12).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{initRound}(\textit{deck, players})
\begin{itemize}
    \item transition: Validate that \textit{players} contains exactly two distinct players and \textit{deck} has enough cards. Deal \textbf{InitialHandSize} cards from \textit{deck} to each player's hand. Draw one card from the deck to initialize \textit{discardPile} and set \textit{topCard}. Set \textit{forcedSuit} := None. Set \textit{currentTurn} to the starting player (policy-defined).
    \item output: Return the initialized \texttt{RoundState}.
    \item exception: \texttt{InvalidPlayers} if \textit{players} is not a valid 1v1 set. \texttt{InvalidDeck} if the deck lacks sufficient cards or is malformed.
\end{itemize}

\noindent\textbf{isPlayable}(\textit{state, playerId, card})
\begin{itemize}
    \item transition: Validate \textit{state}, \textit{playerId}, and that \textit{card} is in \textit{state.hands[playerId]}. Let \textit{t} := \textit{state.topCard}.
    \item output: Return \texttt{true} iff the following rule holds:
    \begin{itemize}
        \item If \textit{card} is a wildcard (rank 10), then \texttt{true}.
        \item Else if \textit{state.forcedSuit} $\neq$ None, then \texttt{true} iff \textit{card.suit} equals \textit{state.forcedSuit}.
        \item Else (no forced suit), \texttt{true} iff at least one is satisfied:
        \begin{itemize}
            \item match suit: \textit{card.suit} = \textit{t.suit}
            \item match rank: \textit{card.rank} = \textit{t.rank}
            \item dozenal-sum: \textit{card} and \textit{t} are not face cards and \textit{card.rank} + \textit{t.rank} = \textbf{DozenalTargetDecimal}
        \end{itemize}
    \end{itemize}
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed. \texttt{InvalidPlayer} if \textit{playerId} is not in the round. \texttt{InvalidCard} if \textit{card} is malformed or not in the player's hand.
\end{itemize}

\noindent\textbf{getPlayableCards}(\textit{state, playerId})
\begin{itemize}
    \item transition: Validate \textit{state} and \textit{playerId}. For each \textit{card} in \textit{state.hands[playerId]}, include it in the result iff \textbf{isPlayable}(\textit{state, playerId, card}) is \texttt{true}.
    \item output: Return the sequence of playable cards (possibly empty).
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed. \texttt{InvalidPlayer} if \textit{playerId} is not in the round.
\end{itemize}

\noindent\textbf{applyPlay}(\textit{state, playerId, card, chosenSuit})
\begin{itemize}
    \item transition: Validate \textit{state} and turn order (must be \textit{playerId}'s turn). Require \textbf{isPlayable}(\textit{state, playerId, card}) = \texttt{true}. Remove \textit{card} from \textit{state.hands[playerId]} and push it onto \textit{state.discardPile}; set \textit{state.topCard} := \textit{card}.
    \begin{itemize}
        \item If \textit{card} is a wildcard (rank 10), then \textit{chosenSuit} must be provided; set \textit{state.forcedSuit} := \textit{chosenSuit}.
        \item Else set \textit{state.forcedSuit} := None.
    \end{itemize}
    Advance \textit{state.currentTurn} to the other player.
    \item output: Return the updated \texttt{RoundState}.
    \item exception: \texttt{IllegalMove} if the play is not legal under the rules (including playing out of turn). \texttt{InvalidSuitChoice} if \textit{card} is wildcard and \textit{chosenSuit} is missing/invalid. \texttt{InvalidRoundState}/\texttt{InvalidPlayer}/\texttt{InvalidCard} as applicable.
\end{itemize}

\noindent\textbf{mustDraw}(\textit{state, playerId})
\begin{itemize}
    \item transition: Validate \textit{state} and \textit{playerId}. Compute \textit{playables} := \textbf{getPlayableCards}(\textit{state, playerId}).
    \item output: Return \texttt{true} iff \textit{playables} is empty.
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed. \texttt{InvalidPlayer} if \textit{playerId} is not in the round.
\end{itemize}

\noindent\textbf{applyDraw}(\textit{state, playerId})
\begin{itemize}
    \item transition: Validate \textit{state} and turn order. Require \textbf{mustDraw}(\textit{state, playerId}) = \texttt{true}. Pop the top card from \textit{state.drawPile} and add it to \textit{state.hands[playerId]}. (Whether the drawn card may be played immediately is handled by the caller/game flow policy; this module only applies the draw.)
    \item output: Return the updated \texttt{RoundState}.
    \item exception: \texttt{EmptyDeck} if \textit{state.drawPile} is empty. \texttt{InvalidRoundState}/\texttt{InvalidPlayer} as applicable.
\end{itemize}

\noindent\textbf{isRoundOver}(\textit{state})
\begin{itemize}
    \item transition: Validate \textit{state}. Check whether any player's hand is empty.
    \item output: Return \texttt{true} iff $\exists p$ such that \textit{state.hands[p]} is empty; otherwise \texttt{false}.
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} exact move-validation criteria, including how matching ranks, suits, dozenal sums, and special cards (wildcard) are handled.
    \item \textbf{Service:} confirms whether a proposed play is legal and enumerates valid plays for a player based on the current round situation; also provides helpers to initialize a round and apply state transitions for play/draw.
    \item This module does \textbf{not} compute scoring; scoring is handled by a separate module.
    \item Dozenal interpretation is delegated to \textbf{M18}; this module uses the decimal target (\textbf{DozenalTargetDecimal}) corresponding to base-12 ``10''.
\end{itemize}

\newpage
\section{MIS of Scoring Module (M17)}\label{sec:scoring-module}

\subsection{Module}
Scoring

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:base-conversion-module]{M18 Base Conversion Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{FaceCardScore}: nat := 10
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
computeRoundScore & winner: PlayerID, loserHand: seq of Card & string & InvalidHand \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item This module is called only when a round ends (i.e., the winner has emptied their hand).
    \item The round score equals the sum of the remaining cards in the loser's hand.
    \item Face cards (J/Q/K) are worth \textbf{FaceCardScore}.
    \item Rank 10 (including wildcard 10) is worth 10.
    \item Numeric cards are worth their rank value.
    \item The returned score is represented in dozenal (base-12) using \textbf{M18.decimalToDozenal}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{computeRoundScore}(\textit{winner, loserHand})
\begin{itemize}
    \item transition: Validate \textit{loserHand}. Compute a decimal total:
    \[
        total = \sum_{c \in loserHand} scoreValue(c)
    \]
    where:
    \[
        scoreValue(c) =
        \begin{cases}
        \textbf{FaceCardScore} & \text{if } c \text{ is a face card} \\
        10 & \text{if } rank(c)=10 \\
        rank(c) & \text{otherwise}
        \end{cases}
    \]
    Convert the decimal \textit{total} to dozenal by calling \textbf{M18.decimalToDozenal}(\textit{total}).
    \item output: Return the dozenal score string for the round winner.
    \item exception: \texttt{InvalidHand} if any card in \textit{loserHand} is malformed or has an unsupported rank.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the scoring equation that converts remaining cards into round points.
    \item \textbf{Service:} calculates the round score at the end of a round and returns it in dozenal form for display.
\end{itemize}


\newpage
\section{MIS of Base Conversion Module (M18)}\label{sec:base-conversion-module}

\subsection{Module}
Base Conversion

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DozenalBase}: nat := 12
    \item \textbf{DecimalBase}: nat := 10
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
decimalToDozenal & n: int & string & InvalidNumberFormat \\
dozenalToDecimal & s: string & int & InvalidNumberFormat \\
normalizeDozenal & s: string & string & InvalidNumberFormat \\
isValidDozenal & s: string & boolean & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item The dozenal representation uses a fixed, consistent mapping between values and symbols for digits (including the two extra digits beyond 0--9).
    \item Input strings for conversion do not contain whitespace unless explicitly handled by \texttt{normalizeDozenal}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{decimalToDozenal}(\textit{n})
\begin{itemize}
    \item transition: Convert integer \textit{n} from base \textbf{DecimalBase} to base \textbf{DozenalBase} using repeated division and remainder; map each remainder to the corresponding dozenal digit symbol; produce the resulting string (including a sign if \textit{n} $<$ 0).
    \item output: Return a dozenal \texttt{string} representing \textit{n}.
    \item exception: \texttt{InvalidNumberFormat} if \textit{n} is not a valid finite integer (implementation-defined; e.g., NaN or non-integer input in a loosely-typed context).
\end{itemize}

\noindent\textbf{dozenalToDecimal}(\textit{s})
\begin{itemize}
    \item transition: Normalize \textit{s} (optional). Validate that every character is a recognized dozenal digit symbol (and optional leading sign). Compute the decimal value by positional evaluation in base \textbf{DozenalBase}.
    \item output: Return the decimal \texttt{int} value represented by \textit{s}.
    \item exception: \texttt{InvalidNumberFormat} if \textit{s} contains invalid digits/symbols or is otherwise malformed.
\end{itemize}

\noindent\textbf{normalizeDozenal}(\textit{s})
\begin{itemize}
    \item transition: Standardize \textit{s} into canonical dozenal format (e.g., trim whitespace, normalize casing, map alternate symbols to the project-standard digit symbols).
    \item output: Return the normalized dozenal \texttt{string}.
    \item exception: \texttt{InvalidNumberFormat} if \textit{s} cannot be normalized into a valid dozenal representation.
\end{itemize}

\noindent\textbf{isValidDozenal}(\textit{s})
\begin{itemize}
    \item transition: Check whether \textit{s} is a syntactically valid dozenal string under the module's digit-symbol mapping.
    \item output: Return \texttt{true} iff \textit{s} is valid; otherwise return \texttt{false}.
    \item exception: None.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the mapping of digits and symbols used to move between decimal and dozenal numbers.
    \item \textbf{Service:} translates numeric values to and from dozenal form for scoring logic and UI presentation.
    \item This is a behaviour-hiding utility module: callers rely on the conversion API without knowing the digit-symbol mapping details.
\end{itemize}


\newpage
\section{MIS of Game Actions Module (M19)}\label{sec:game-actions-module}

\subsection{Module}
Game Actions Module

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:game-engine-module]{M15 Game Engine Module}
    \item \hyperref[sec:rules-module]{M16 Rules Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}
\begin{center}
    %
    %  booktabs (\toprule) 
    %
    \begin{tabular}{p{3.5cm} p{3.5cm} p{3cm} >{\raggedright\arraybackslash}p{4cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        createAction & ActionType, Parameters & Action & InvalidActionType \\
        validateAction & Action, GameState & Boolean & InvalidMoveException \\
        executeAction & Action, GameState & GameState & ActionExecutionError \\
        undoAction & Action, GameState & GameState & None \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{pendingActions}: a queue of unexecuted player actions.
    \item \textbf{lastAction}: most recent action for rollback or replay.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Backend execution environment.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Each action follows the command pattern and can be validated independently.
    \item The game engine (M15) ensures single-threaded execution for action safety.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{createAction}(\textit{ActionType, Parameters})
\begin{itemize}
    \item output: constructs an action object from parameters (e.g., play card 8 spade).
\end{itemize}

\noindent\textbf{validateAction}(\textit{Action, GameState})
\begin{itemize}
    \item output: checks if the action is allowed under current rules (by calling M16).
\end{itemize}

\noindent\textbf{executeAction}(\textit{Action, GameState})
\begin{itemize}
    \item transition: applies changes to game state (by calling M15) and notifies observers.
    \item output: \texttt{GameState}.
\end{itemize}

\noindent\textbf{undoAction}(\textit{Action, GameState})
\begin{itemize}
    \item transition: reverses the last applied change for testing or debugging.
    \item output: \texttt{GameState}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{serializeAction()}: converts an action into a string or JSON for replay logging.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item This module improves maintainability by isolating gameplay logic into self-contained actions, enabling undo/redo and deterministic testing.
\end{itemize}

\newpage
\section{MIS of Operating System Module (M20)}\label{sec:os-module}

\subsection{Module}
Operating System Module

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}
\begin{center}
    \begin{tabular}{p{4cm} p{3.5cm} p{3cm} p{3cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        scheduleTask & Function, Delay & None & None \\
        readFile & Path & String & IOError \\
        writeFile & Path, String & None & IOError \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item System scheduler queue.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Host OS file system and process manager.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item OS provides basic thread safety and asynchronous task execution.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{scheduleTask}(\textit{Function, Delay})
\begin{itemize}
    \item transition: executes a callback after a specified delay.
    \item output: \texttt{None}.
\end{itemize}

\noindent\textbf{readFile}(\textit{Path})
\begin{itemize}
    \item output: retrieves content from a local file path.
\end{itemize}

\noindent\textbf{writeFile}(\textit{Path, String})
\begin{itemize}
    \item transition: writes content to a file.
    \item output: \texttt{None}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{validatePath(path)}: checks file system accessibility.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item This module ensures portability across Windows, macOS, and Linux.
\end{itemize}

\newpage
\section{MIS of Browser Runtime Module (M21)}\label{sec:browser-runtime-module}

\subsection{Module}
Browser Runtime Module

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}
\begin{center}
    \begin{tabular}{p{4cm} p{3.5cm} p{3cm} p{4cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        registerEvent & String, Callback & None & None \\
        renderElement & HTMLElement & None & None \\
        storeLocalData & Key, Value & None & StorageException \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Local storage cache, active event listeners.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser environment (HTML5, Web APIs).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item All browser APIs are available in the execution environment.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{registerEvent}(\textit{String, Callback})
\begin{itemize}
    \item transition: binds a function to a specified DOM event.
    \item output: \texttt{None}.
\end{itemize}

\noindent\textbf{renderElement}(\textit{HTMLElement})
\begin{itemize}
    \item transition: draws a UI element on the screen.
    \item output: \texttt{None}.
\end{itemize}

\noindent\textbf{storeLocalData}(\textit{Key, Value})
\begin{itemize}
    \item transition: writes data into browser storage for persistence.
    \item output: \texttt{None}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{serialize(obj)}: converts objects into storable string format.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item Must be compatible with modern browsers and responsive frameworks.
\end{itemize}

\newpage
\section{MIS of Database Module (M22)}\label{sec:database-module}

\subsection{Module}
Database Module

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}
\begin{center}
    \begin{tabular}{p{4cm} p{3.5cm} p{3cm} p{4.5cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        connect & ConnectionString & Boolean & DatabaseConnectionError \\
        query & SQLStatement & ResultSet & QueryError \\
        insertRecord & Table, Data & Boolean & InsertError \\
        updateRecord & Table, Data & Boolean & UpdateError \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{dbConnection}: current active database session.
    \item \textbf{cache}: optional in-memory data cache.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Database server or local SQLite environment.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Database connection string is valid and accessible.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{connect}(\textit{ConnectionString})
\begin{itemize}
    \item transition: establishes a session with the database server.
    \item output: \texttt{Boolean}.
\end{itemize}

\noindent\textbf{query}(\textit{SQLStatement})
\begin{itemize}
    \item output: executes read operations and returns result sets.
\end{itemize}

\noindent\textbf{insertRecord}(\textit{Table, Data})
\begin{itemize}
    \item transition: inserts a new entry into the specified table.
    \item output: \texttt{Boolean}.
\end{itemize}

\noindent\textbf{updateRecord}(\textit{Table, Data})
\begin{itemize}
    \item transition: modifies existing records based on key values.
    \item output: \texttt{Boolean}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{sanitizeInput()}: prevents SQL injection attacks.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item Database operations must remain atomic and logged to ensure integrity and traceability.
\end{itemize}


%~\newpage
%
%\section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}
%
%\subsection{Module}
%
%\wss{Short name for the module}
%
%\subsection{Uses}
%
%
%\subsection{Syntax}
%
%\subsubsection{Exported Constants}
%
%\subsubsection{Exported Access Programs}
%
%\begin{center}
%\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
%\hline
%\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
%\hline
%\wss{accessProg} & - & - & - \\
%\hline
%\end{tabular}
%\end{center}
%
%\subsection{Semantics}
%
%\subsubsection{State Variables}
%
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}
%
%\subsubsection{Environment Variables}
%
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
%
%\subsubsection{Assumptions}
%
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}
%
%\subsubsection{Access Routine Semantics}
%
%\noindent \wss{accessProg}():
%\begin{itemize}
%\item transition: \wss{if appropriate} 
%\item output: \wss{if appropriate} 
%\item exception: \wss{if appropriate} 
%\end{itemize}
%
%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}
%
%\subsubsection{Local Functions}
%
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}